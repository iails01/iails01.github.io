<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="robots" content="noindex">
  
  <title>Git 的常用命令记录 - Iails&#39;s posts</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=工具,Git>
  
    <meta name="description" content="The Personal blog of Iails, a programer.">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  

  
<link rel="stylesheet" href="/css/style.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.css">
<style>:root{--hl-color:#abb2bf;--hl-bg:#282c34;--hltools-bg:#21252b;--hltools-color:#bbbbbc;--hlnumber-bg:#282c34;--hlnumber-color:#495162;--hlscrollbar-bg:#373c47;--hlexpand-bg:linear-gradient(180deg,rgba(40,44,52,0.1),rgba(40,44,52,0.9))}</style>
    <style>
    .code-expand-btn:not(.expand-done) ~ div.codeblock,
    .code-expand-btn:not(.expand-done) ~ * div.codeblock {
      overflow: hidden;
      height: 360px;
    }
    </style>
  <!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"></head>

  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">♪</a>
    <div class="subtitle"></div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/tags/" class="menu-item-link">Tags</a>
        </li>
      
    </ul>
  </nav>
</header>

<article class="post">
  <div class="post-title">
    <h1 class="article-title">Git 的常用命令记录</h1>
  </div>
   <div class="post-meta" style="color:#000000;font-size:16px;">
    <span class="post-time">2018-11-07</span> <br>
  </div>
  <div class="post-content">
    <h1 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1. 安装git"></a>1. 安装git</h1><ul>
<li>centos7自带git1.8</li>
</ul>
<p>查看安装过的包：<code>yum list installed</code>，有点慢耐心等待。</p>
<h2 id="1-1-删除自带：sudo-yum-remove-git"><a href="#1-1-删除自带：sudo-yum-remove-git" class="headerlink" title="1.1 删除自带：sudo yum remove git"></a>1.1 删除自带：<code>sudo yum remove git</code></h2><h1 id="1-2-安装前环境配置："><a href="#1-2-安装前环境配置：" class="headerlink" title="1.2 安装前环境配置："></a>1.2 安装前环境配置：</h1><figure class="shiki"><div class='codeblock'><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">sudo yum install -y curl-devel expat-devel gettext-devel openssl-devel zlib-devel asciidoc xmlto perl-devel perl-CPAN autoconf*</span></span></code></pre></div></div></figure>

<p>还需要gcc</p>
<h1 id="1-3-下载git2-2-1并将git添加到环境变量中"><a href="#1-3-下载git2-2-1并将git添加到环境变量中" class="headerlink" title="1.3 下载git2.2.1并将git添加到环境变量中"></a>1.3 下载git2.2.1并将git添加到环境变量中</h1><figure class="shiki shell"><div class='codeblock'><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">wget</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">https://github.com/git/git/archive/v2.2.1.tar.gz</span></span>
<span class="line"><span style="color: #61AFEF">tar</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-zxvf</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">v2.2.1.tar.gz</span></span>
<span class="line"><span style="color: #56B6C2">cd</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">git-2.2.1</span></span>
<span class="line"><span style="color: #61AFEF">make</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">configure</span></span>
<span class="line"><span style="color: #61AFEF">./configure</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--prefix=/usr/local/git</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--with-iconv=/usr/local/libiconv</span></span>
<span class="line"><span style="color: #61AFEF">make</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">all</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">doc</span></span>
<span class="line"><span style="color: #61AFEF">make</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">install</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">install-doc</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">install-html</span></span>
<span class="line"><span style="color: #7F848E; font-style: italic"># 以root用户执行“”内整条语句，因为`&gt;`需要再次授权</span></span>
<span class="line"><span style="color: #61AFEF">sudo</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">sh</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-c</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&quot;echo &#39;export PATH=</span><span style="color: #56B6C2">\$</span><span style="color: #98C379">PATH:/usr/local/git/bin&#39; &gt;  /etc/profile.d/git.sh&quot;</span></span>
<span class="line"><span style="color: #56B6C2">source</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">/etc/profile.d/git.sh</span></span></code></pre></div></div></figure>


<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="暂存区-索引（stage-index）"><a href="#暂存区-索引（stage-index）" class="headerlink" title="暂存区&#x2F;索引（stage&#x2F;index）"></a>暂存区&#x2F;索引（stage&#x2F;index）</h2><ul>
<li>暂存区是所有分支共享的，checkout到另外的分支，暂存区的内容不变</li>
</ul>
<p><code>git rm</code> ： 同时从工作区和暂存区中删除文件。即本地的文件也被删除了。</p>
<p><code>git rm --cached</code> ： 从暂存区中删除文件，并且将文件移出版本控制，但是本地文件还存在。</p>
<p>使用<code>git reset</code>也可操作暂存区</p>
<p><code>git restore --staged &lt;file&gt;...</code>：可以将文件移出暂存区</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>代码托管网站，主要看email，用email地址来匹配自己的账户名的邮件地址，如果相同，代码托管网站就认为此操作是账户所有者的操作。</p>
<figure class="shiki"><div class='codeblock'><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">git config --get user.name # 查看本地user.name属性，若没有配置则不显示，此时push时使用global属性(?)</span></span>
<span class="line"><span style="color: #abb2bf">git config user.name abc # 设置本地属性，config文件放在.git目录下，该文件有多个段，user.name在user段中</span></span>
<span class="line"><span style="color: #abb2bf">git config --global user.name abc # 设置全局属性，该属性放在。。不清楚</span></span></code></pre></div></div></figure>

<p>换行符的配置：<code>core.autocrlf</code></p>
<ul>
<li>true: 提交时转换为 LF，检出时转换为 CRLF</li>
<li>false: 提交检出均不转换</li>
<li>input: 提交时转换为LF，检出时不转换</li>
</ul>
<p>忽略大小写配置：<code>core.ignorecase</code></p>
<ul>
<li>true: 分支名称比较时会忽略大小写</li>
<li>false: 分支名称比较时会考虑大小写</li>
</ul>
<h2 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h2><figure class="shiki sh"><div class='codeblock'><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">config</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--global</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">http.proxy</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">http://127.0.0.1:7890</span></span></code></pre></div></div></figure>

<h2 id="gitignore"><a href="#gitignore" class="headerlink" title="gitignore"></a>gitignore</h2><p>查看文件是否被排除，若被排除<strong>会显示出被排除的文件</strong>。<code>pathname</code>是该文件路径</p>
<figure class="shiki"><div class='codeblock'><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">git check-ignore [&lt;options&gt;] &lt;pathname&gt;…</span></span></code></pre></div></div></figure>

<p>刚开始新建一个项目可能会把.idea&#x2F;workspace.xml等这种系统文件或编译中间过程的文件都用git add添加到了git版本库中来管理，这样即使后来添加了.gitignore文件也不能忽略掉已经添加到版本库中的文件，这时需要用 <code>git rm [--cache] xxx文件</code>从版本管理库中删除，不再跟踪此文件。加了<code>--cache</code>代表不会删除工作空间中的文件</p>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><blockquote>
<p>远程的commit&#x2F;branch在本地了对应一个只读的<code>远程名/(commit|branch)</code></p>
</blockquote>
<ul>
<li><code>git add file</code>：同一个文件，第2次会覆盖第1次</li>
<li><code>git diff [--options] [--] [&lt;path&gt;...]</code>：工作空间与暂存区的文件内容区别</li>
<li><code>git log</code>：记录当前的commit及其之前的commit</li>
<li><code>git reflog</code>：记录HEAD的移动记录</li>
<li>在commit时添加<code>-a</code>参数， Git就会自动把所有已经跟踪过<br>的文件暂存起来一并提交，从而跳过git add步骤</li>
<li><code>git log --graph --pretty=oneline --abbrev-commit</code></li>
</ul>
<h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><ul>
<li><code>git commit --amend</code>，创建一个当前节点<code>C1</code>的兄弟节点的<code>C2</code>，<code>C2</code>在<code>C1</code>的的基础上，添加了本次的修改内容。</li>
</ul>
<h2 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h2><ul>
<li><code>git branch -vv</code>：查看本地分支关联的远程分支</li>
<li><code>git branch --set-upstream-to=origin/master master</code>：设置upstream</li>
<li><code>git branch -f &lt;branch&gt; &lt;destcommit&gt;</code>：将<code>&lt;branch&gt;</code>分支指针指向到<code>&lt;destcommit&gt;</code></li>
<li><code>git branch &lt;branch&gt; &lt;destcommit&gt;</code>：在destcommit上创建一个branch</li>
<li><code>git branch -u &lt;remote&gt;/&lt;branch&gt; [&lt;branch&gt;]</code>：本地的<code>branch</code> tracking 远程的<code>branch</code>。本地<code>branch</code>不指定默认为当前分支</li>
<li><code>git branch -d &lt;branch&gt;</code>：删除本地分支</li>
<li><code>git push origin -d &lt;branch&gt;</code>：删除远程的分支</li>
</ul>
<h2 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h2><ul>
<li><p><code>git checkout &lt;commit&gt;(~\d|^(\d|))*</code>：<code>~2</code>代表<code>commit</code>往上跳两次；<code>^2</code>代表<code>commit</code>往上跳一个，但是上面可能有很多个选择，选第二个。未给出数字代表1</p>
</li>
<li><p><code>git checkout -b [分支名] [远程名]/[分支名]</code>：建立一個新的 branch 並且它會 track remote branch，并checkout到这个branch。</p>
</li>
<li><p><code>git checkout -b [分支名] &lt;commit&gt;</code>：在commit所在位置建立一個新的 branch，并checkout到这个branch。</p>
</li>
<li><p><code>git checkout -- filename</code>：丢弃修改，让这个文件回到最近一次git commit或git add时的状态。</p>
</li>
</ul>
<h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><ul>
<li><code>git stash list</code>：列出当前所有的stash</li>
<li><code>git stash save [-p] [&lt;message&gt;]</code>：把当前未提交的代码保存为一个stash，并且还原文件到未修改状态。-p 代表进入一个交互式界面，可以决定如何处理每个未提交的文件。message可以给stash添加一个描述信息。</li>
<li><code>git stash (pop|apply) [&lt;stash-name&gt;]</code>：pop会将stash删除并且应用，apply只是应用。<code>stash-name</code>不指定默认代表第一个stash</li>
</ul>
<h2 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h2><ul>
<li><code>git revert &lt;commit&gt;</code>：将某个commit取消，原理是提交一个修改，改修改的内容是指示此commit被取消</li>
</ul>
<h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><ul>
<li><code>git reset -- files</code>：撤消暂存区中的文件</li>
</ul>
<p><code>git reset [&lt;option&gt;] &lt;commit&gt;</code>,option默认mixed</p>
<ul>
<li><code>--soft</code>，仅仅重置当前分支到指定的commit，index和working tree不改变</li>
</ul>
<p>Does not touch the index file or the working tree at all (but resets the head to <commit>, just like all modes do). This leaves all your changed files “Changes to be committed”, as git status would put it.</p>
<ul>
<li><code>--mixed</code>，重当前分支到指定的commit，还清空(?)了index</li>
</ul>
<p>Resets the index but not the working tree (i.e., the changed files are preserved but not marked for commit) and reports what has not been updated. This is the default action.</p>
<p>If -N is specified, removed paths are marked as intent-to-add (see git-add(1)).</p>
<ul>
<li><code>--hard</code>，重置当前分支到指定的commit，还清空(?)了index，并且将working tree的文件都修改为这个commit的状态。</li>
</ul>
<p>Resets the index and working tree. Any changes to tracked files in the working tree since <commit> are discarded.</p>
<h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><ul>
<li><code>git merge &lt;commit&gt;</code></li>
</ul>
<h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><ul>
<li><code>git rebase &lt;commit1&gt;</code>：将<code>(当前节点与commit1往上的汇合公共节点(若在同一条路径则没有效果),当前节点]</code>之间所有commit依次复制到commit1下</li>
<li><code>git rebase -i &lt;commit1&gt;</code>：将<code>(当前节点与commit1往上的汇合公共节点(若在同一条路径仍然有效果),当前节点]</code>范围内的commit重排序并选择需要的commit按顺序复制到该<code>commit1</code>下的一个新分支(并不会真的创建一个branch)，并将HEAD&#x2F;当前分支  移动到该分支末尾。</li>
<li>&#x3D;&#x3D;<code>git rebase 其它参数 &lt;branch&gt;</code>: 先checkout到branch，然后再<code>rebase 其它参数</code>，<code>merge</code>而不可以这样&#x3D;&#x3D;</li>
</ul>
<h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><ul>
<li><code>git cherry-pick &lt;commit&gt;...</code>：将这些commit依次复制到HEAD节点下面</li>
</ul>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><p>在做 clone 的時候，git 會針對每一個在 remote 上面的 branch 建立一個 branch （例如 o&#x2F;master），之後它會建立一個 local branch 來追蹤目前在 remote 上面的 active branch，在大部份的情況下，幾乎都是設定 master branch。</p>
<p>一旦 git 完成這個動作，你就只會有一個 local branch ，但是你可以看到所有在 remote 上面的不同的 branch，對於 local 和 remote 來說的話，這樣子是最好的</p>
<h2 id="remote-tracking"><a href="#remote-tracking" class="headerlink" title="remote tracking"></a>remote tracking</h2><p>决定了<code>push</code>的目的地以及<code>pull</code>后合并的目标。</p>
<p>另外一個設定 remote tracking(track的是本地的remote分支) 的方法是使用 git branch -u 這一個指令，執行</p>
<figure class="shiki"><div class='codeblock'><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">git branch -u &lt;remote&gt;/&lt;branch&gt; &lt;localBranch&gt;（foo必须存在）</span></span></code></pre></div></div></figure>

<p>如果你現在已經 checkout 到 localBranch 上面了，你就可以省略掉它：</p>
<figure class="shiki"><div class='codeblock'><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">git branch -u &lt;remote&gt;/&lt;branch&gt;</span></span></code></pre></div></div></figure>
<h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p><code>git push origin</code> 表示，将当前分支推送到origin主机的对应分支，如果当前分支只有一个追踪分支，那么主机名都可以省略。 </p>
<p><code>git push -u origin master</code> 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用<code>git push</code>了。</p>
<ul>
<li><code>git push</code>：推送HEAD所在branch的commit到remote branch，同時对应的本地远程分支 <code>&lt;remote&gt;/&lt;branch&gt;</code> 也一併更新！HEAD必须在branch节点</li>
<li><code>git push &lt;remote&gt; &lt;source&gt;:&lt;destination&gt;</code>：先到我的 repo 中的 <code>source</code>commit(可用<code>~和^</code>)，抓下所有的 commit，然後到本地<code>&lt;remote&gt;/&lt;destination&gt;</code>分支所对应的远端分支，檢查 它 的 commit 有沒有跟我的 repo 一致，如果沒有，就更新远端分支，并且更新本地remote分支。若没有<code>destination</code>将会创建</li>
<li><code>git push &lt;remote&gt; &lt;place&gt;</code>：等价于<code>git push &lt;remote&gt; &lt;place&gt;:&lt;place&gt;</code></li>
<li><code>git push &lt;remote&gt; :&lt;branch&gt;</code>：删除remote的branch分支，同时删除本地对应的remote分支</li>
</ul>
<h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><ul>
<li><code>git fetch</code>：更新本地仓库的remote分支，即下载远程分支中新的commit和分支信息，会移动所有本地remote branch，保持本地remote分支和远程仓库的同步。非remote分支不会变化。</li>
<li><code>git fetch &lt;remote&gt; &lt;source&gt;:&lt;destination&gt;</code>：将远端source分支(也可以是commit)更新到本地的destination(没有会创建，但是创建出来的是还未关联远端的)，本地destination当前所有的commit必须与远端的前面部分相同。不会更新本地的remote分支。</li>
<li><code>git fetch &lt;remote&gt; &lt;place&gt;</code>：等价于<code>git fetch &lt;remote&gt; &lt;place&gt;:&lt;remote&gt;/&lt;place&gt;</code>，只更新本地的某个remote分支</li>
<li><code>git fetch &lt;remote&gt; :&lt;dest&gt;</code>：在当前节点建立一个叫dest的新本地分支和远端无关联，很没用的命令。</li>
</ul>
<h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><ul>
<li><code>git pull</code>：git pull 其實就是 git fetch 跟 git merge 的循序執行的結果(但是只会更新当前所在分支)，而且 merge 的 branch 就是 fetch 所更新的 branch。它也能加<code>fetch</code>的参数。</li>
<li><code>git pull --rebase</code>：把<code>merge</code>换成<code>rebase</code></li>
<li><code>例子：</code>：<code>git pull origin foo</code>&#x3D;&gt;<code>git fetch origin foo; git merge fetch的dest</code>&#x3D;&gt;<code>git fetch origin foo:origin/foo; git merge origin/foo</code>顺序执行（注意<code>merge b</code>是把<code>b</code> merge到当前所在的branch）。</li>
</ul>
<h2 id="stash-1"><a href="#stash-1" class="headerlink" title="stash"></a>stash</h2><p><code>git stash</code>：将工作空间中被track的文件中未<code>add</code>的修改压入栈，操作完成后使用<code>status</code>会显示<code>nothing to commit, working tree clean</code>。这时就可以<code>checkout</code>到其它branch做其它操作，完成之后可以再<code>checkout</code>回来使用<code>git stash pop</code>从栈中弹出栈顶元素，并且恢复工作空间。在A分支stash后在B分支pop stash也是可以的。</p>
<h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><ul>
<li><p><code>git tag &lt;tagName&gt; &lt;commit&gt;</code>：创建一个与commit关联的tag，若commit未指定则代表HEAD。</p>
</li>
<li><p><code>git describe &lt;ref&gt;</code>：显示离<code>ref</code>最近的<code>tag</code>。<code>ref</code>可以是任何可以被解释为<code>commit</code>的位置(<code>tag,commit,branch</code>)，<code>ref</code>未给出代表<code>HEAD</code>。指令输出<code>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</code>，<code>numCommits</code>代表<code>tag</code>离<code>ref</code>有几个<code>commit</code>(起点到终点的跳数)，<code>hash</code>表示<code>ref</code>所代表的<code>commit</code>的前7位<code>hash</code>。当<code>ref</code>本身含有标签时，则只输出标签。</p>
</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="修改之前提交的某个commit（C1）"><a href="#修改之前提交的某个commit（C1）" class="headerlink" title="修改之前提交的某个commit（C1）"></a>修改之前提交的某个commit（<code>C1</code>）</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://git.mo.mk/">https://git.mo.mk</a> <code>4-2</code> 或 <code>4-2</code></p>
</blockquote>
<p>使用<code>rebase</code>：</p>
<ul>
<li><code>rebase -i C1^</code>，把<code>C1</code>重排序到最前面</li>
<li>此时基于<code>C1</code>修改之后再<code>commit -amend</code>添加修改到新<code>C1&#39;</code></li>
<li>然后再<code>rebase -i C1^</code>，把<code>C1&#39;</code>放到最后</li>
</ul>
<p>或使用<code>cherry-pick</code>：</p>
<ul>
<li><code>checkout C1</code></li>
<li>此时基于<code>C1</code>修改之后再<code>commit -amend</code>添加修改到新<code>C1&#39;</code></li>
<li>然后再<code>cherry-pick C1之后所有的commit</code></li>
</ul>
<h3 id="合并commit"><a href="#合并commit" class="headerlink" title="合并commit"></a>合并commit</h3><p>当前分支后退3个节点，将最新3个提交放到stage，然后提交。当前分支会生成一个新的提交包括了所有的修改。<br>建议先在本地打一个tag标识再做这个操作，否则操作完可能找不到原先的一个一个的提交记录了。</p>
<figure class="shiki shell"><div class='codeblock'><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--soft</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">HEAD~3</span></span>
<span class="line"><span style="color: #61AFEF">--</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">下面这个命令可以拼接所有的提交message作为合并后的提交的message.</span></span>
<span class="line"><span style="color: #61AFEF">--</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">%B表示只显示每个提交的消息内容</span></span>
<span class="line"><span style="color: #61AFEF">--</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">在Git中，HEAD@{</span><span style="color: #D19A66">1</span><span style="color: #98C379">}是一个引用，它指向HEAD在一次移动之前所在的位置。这是Git的&quot;引用日志&quot;（reflog）的一部分，它记录了HEAD和其他引用的历史移动。</span></span>
<span class="line"><span style="color: #61AFEF">--</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">commit</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--edit</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-m</span><span style="color: #98C379">&quot;$(</span><span style="color: #61AFEF">git</span><span style="color: #98C379"> log </span><span style="color: #D19A66">--format=%B</span><span style="color: #98C379"> </span><span style="color: #D19A66">--reverse</span><span style="color: #98C379"> HEAD..HEAD@{</span><span style="color: #D19A66">1</span><span style="color: #98C379">})&quot;</span></span>
<span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">commit</span></span></code></pre></div></div></figure>

<h3 id="删除未跟踪的文件"><a href="#删除未跟踪的文件" class="headerlink" title="删除未跟踪的文件"></a>删除未跟踪的文件</h3><ul>
<li><code>-d</code>：删除未跟踪的目录。</li>
<li><code>-f</code>：强制执行删除操作，即使它会导致数据丢失。</li>
</ul>
<figure class="shiki shell"><div class='codeblock'><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">clean</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-df</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #98C379">di</span><span style="color: #ABB2BF">r&gt;</span></span></code></pre></div></div></figure>

<h2 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h2><ul>
<li>修改之前已经提交的记录：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sodaslay/article/details/72948722">https://blog.csdn.net/sodaslay/article/details/72948722</a><br>，但是commit仍然没被删掉，在本地git仓库中仍然可以checkout到那个commit。但是force push后远程中的commit记录应该就没有了，那么其它人clone下来的也将没有。</li>
</ul>

  </div>
  <div class="post-footer">
    
      <ul class="post-tag-list">
        
          <li class="post-tag-list-item">
            <a class="post-tag" href="/tags/?selected=%E5%B7%A5%E5%85%B7">工具</a>
          </li>
        
          <li class="post-tag-list-item">
            <a class="post-tag" href="/tags/?selected=Git">Git</a>
          </li>
        
      </ul>
    

    <a href="#top" class="top">Back to Top</a>
  </div>
  
</article>
<footer>
  &copy; 2025
  <span class="author">
    Iails
  </span>

  <span class="right">
    <!-- ICP license placeholder -->
    <a target="_blank" rel="noopener" href="https://github.com/iails01">Github</a>
  </span>
</footer>


    </div>
  <!-- hexo injector body_end start -->
<script src="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.js"></script>

  <script>
  const CODE_CONFIG = {
    beautify: true,
    highlightCopy: true,
    highlightLang: true,
    highlightHeightLimit: 360,
    isHighlightShrink: false,
    copy: {
      success: 'Copy Success',
      error: 'Copy Error',
      noSupport: 'Browser Not Support',
    }
  };
  console.log(
    `%c hexo-shiki-plugin %c v1.0.26 %c https://github.com/nova1751/hexo-shiki-plugin`,
    "color: #fff; background: #5f5f5f",
    "color: #fff; background: #80c8f8",
    ""
  );
  </script>
  <!-- hexo injector body_end end --></body>
</html>
